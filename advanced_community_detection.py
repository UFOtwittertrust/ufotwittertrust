"""
Advanced Community Detection on Synthetic Trust Network

This script:
1. Loads the synthetic trust network generated by `synthetic_trust_generator.py`.
2. Builds a signed graph (positive for trust >50, negative for distrust <50).
3. Detects communities using Louvain modularity optimisation (via CDlib) on the positive-weight subgraph.
   - Louvain automatically determines the number of communities (no preset n).
4. Prints summary statistics about detected communities.
5. Saves a visualisation with nodes coloured by their detected community and edges coloured
   green (trust) / red (distrust).

Run this after generating `synthetic_trust_assignments.json`.
"""

import json
import os
import sys
from collections import defaultdict

import networkx as nx
import matplotlib.pyplot as plt

# Optional CDlib import
try:
    from cdlib import algorithms as cd_algorithms
    from cdlib import viz as cd_viz
    CDLIB_AVAILABLE = True
except ImportError:
    CDLIB_AVAILABLE = False
    print("CDlib not available; falling back to NetworkX Louvain implementation (community-louvain)")
    try:
        import community as community_louvain  # python-louvain package
    except ImportError:
        print("python-louvain package missing. Install with: pip install python-louvain cdlib")
        sys.exit(1)

INPUT_FILE = "trust_assignments.json"
OUTPUT_VIZ = "visualization/actual_detected_communities.png"

TRUST_THRESHOLD = 50  # >50 => trust, <50 => distrust


def build_signed_graph(assignments):
    """Build a signed graph from trust assignments (directed)."""
    G = nx.DiGraph()
    for source, targets in assignments.items():
        for target, score in targets.items():
            # Convert score (0..100) to weight (-1..1)
            weight = (score - 50) / 50  # positive trust, negative distrust
            if weight == 0:
                continue  # ignore neutral edges for clarity
            G.add_edge(source, target, weight=weight)
    return G


def detect_communities(G_positive):
    """Detect communities using Louvain (undirected, weighted)."""
    # Convert to undirected for Louvain
    H = G_positive.to_undirected()

    if CDLIB_AVAILABLE:
        result = cd_algorithms.louvain(H, weight="weight")
        communities = result.communities
    else:
        # Fallback: python-louvain returns dict node->community_id
        partition = community_louvain.best_partition(H, weight="weight")
        communities_dict = defaultdict(list)
        for node, cid in partition.items():
            communities_dict[cid].append(node)
        communities = list(communities_dict.values())
    return communities


def visualize(G_signed, communities, ground_truth_map=None):
    """Visualize signed graph with communities."""
    # Assign colours per community
    import matplotlib.cm as cm
    n_comms = len(communities)
    cmap = cm.get_cmap("tab20", n_comms if n_comms > 0 else 1)
    node_community = {}
    for idx, comm in enumerate(communities):
        for node in comm:
            node_community[node] = idx

    # Layout
    pos = nx.spring_layout(G_signed, seed=42, k=0.3)

    plt.figure(figsize=(14, 10))

    # Draw edges
    trust_edges = [(u, v) for u, v, d in G_signed.edges(data=True) if d["weight"] > 0]
    distrust_edges = [(u, v) for u, v, d in G_signed.edges(data=True) if d["weight"] < 0]
    nx.draw_networkx_edges(G_signed, pos, edgelist=trust_edges, edge_color="green", alpha=0.4, arrows=True, arrowstyle="-|>")
    nx.draw_networkx_edges(G_signed, pos, edgelist=distrust_edges, edge_color="red", alpha=0.4, arrows=True, arrowstyle="-|>", style="dashed")

    # Draw nodes
    for idx, comm in enumerate(communities):
        nx.draw_networkx_nodes(G_signed, pos, nodelist=comm, node_color=[cmap(idx)], label=f"Comm {idx+1} ({len(comm)})", node_size=120, alpha=0.8)

    if G_signed.number_of_nodes() <= 60:
        labels = {n: f"{n}\n({ground_truth_map.get(n, '?')})" if ground_truth_map else n for n in G_signed.nodes()}
        nx.draw_networkx_labels(G_signed, pos, labels=labels, font_size=6)

    plt.title("Detected Communities on Synthetic Trust Network (Ground Truth in Labels)")
    plt.legend()
    plt.axis("off")

    os.makedirs(os.path.dirname(OUTPUT_VIZ), exist_ok=True)
    plt.savefig(OUTPUT_VIZ, dpi=300, bbox_inches="tight")
    plt.close()
    print(f"Community visualisation saved to {OUTPUT_VIZ}")


def compare_communities_with_ground_truth(detected_communities, ground_truth):
    print("\n--- Detected Communities vs. Ground Truth ---")
    if not ground_truth:
        print("  (Ground truth data not available for this dataset.)")
        return

    for i, comm in enumerate(detected_communities):
        print(f"Detected Community {i+1} ({len(comm)} nodes):")
        composition = defaultdict(int)
        for node in comm:
            gt_label = ground_truth.get(node, "Unknown")
            composition[gt_label] += 1
        
        # Sort by count descending for readability
        sorted_composition = sorted(composition.items(), key=lambda item: item[1], reverse=True)
        
        for label, count in sorted_composition:
            print(f"  - {label}: {count} nodes ({count/len(comm)*100:.1f}%)")
        if not comm:
            print("  - Empty community")


def main():
    if not os.path.exists(INPUT_FILE):
        print(f"Input file '{INPUT_FILE}' not found. Run synthetic_trust_generator.py first.")
        sys.exit(1)

    with open(INPUT_FILE, "r") as f:
        data = json.load(f)

    assignments = data["assignments"]
    ground_truth = data.get("ground_truth", {})

    # Build signed graph
    G_signed = build_signed_graph(assignments)

    # Positive-only subgraph for community detection
    G_positive = nx.DiGraph([(u, v, d) for u, v, d in G_signed.edges(data=True) if d["weight"] > 0])

    if G_positive.number_of_nodes() == 0:
        print("No positive trust edges found. Cannot perform community detection.")
        # Optionally, visualize the G_signed graph anyway if it has nodes
        if G_signed.number_of_nodes() > 0:
             print(f"Visualizing the full signed graph with {G_signed.number_of_nodes()} nodes and {G_signed.number_of_edges()} edges (no communities).")
             visualize(G_signed, [], ground_truth_map=ground_truth if ground_truth else None) # Pass empty communities
        else:
            print("The graph is empty.")
        sys.exit(0)

    # Run community detection
    communities = detect_communities(G_positive)

    print(f"Detected {len(communities)} communities.")
    sorted_comms = sorted(communities, key=len, reverse=True)
    for idx, comm in enumerate(sorted_comms, 1):
        print(f"  Community {idx}: {len(comm)} nodes")
        # Print members of the community
        print(f"    Members: {', '.join(sorted(list(comm)))}")

    # Compare with ground truth
    if ground_truth:
        compare_communities_with_ground_truth(sorted_comms, ground_truth)
    else:
        print("\nGround truth data not found in input file for comparison.")

    # Visualize
    visualize(G_signed, sorted_comms, ground_truth_map=ground_truth)


if __name__ == "__main__":
    main() 